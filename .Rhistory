plot(res.fkm,pca=TRUE)
#Tramite la funzione Fclust.index con i seguenti parametri otteniamo
# il valore di Silhouette fuzzy, un parametro che ci indica la qualità
#dei nostri risultati
res.SilF.FKM <- Fclust.index(res.fkm,index="SIL.F",alpha = 1)
str <- paste("Il coefficiente di fuzzy Silhouette è ", toString(res.SilF.FKM))
cat(str)
rm(str)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering_SILF <- miglior.oggetto.fclust.SILF(df,res.fkm)
info.principali.fclust(miglior_clustering)
info.principali.fclust(miglior_clustering_SILF)
plot(miglior_clustering_SILF,pca=TRUE)
library(fclust)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering_SILF <- miglior.oggetto.fclust.SILF(df,res.fkm)
tryCatch( {a <- FKM.ent(df,k=2:6,index="SIL.F",alpha=1) }
, error = function(e)
{cat("Metodi ent e pf.noise eseguiti con stand=1\n")})
b <- 0
tryCatch( {a <- FKM.ent(df,k=2:6,index="SIL.F",alpha=1) }
, error = function(e)
{cat("Metodi ent e pf.noise eseguiti con stand=1\n")})
tryCatch( {a <- FKM.ent(df,k=2:6,index="SIL.F",alpha=1) }
, error = function(e)
{cat("Metodi ent e pf.noise eseguiti con stand=1\n"); b <- 1})
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering_SILF <- miglior.oggetto.fclust.SILF(df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering_SILF <- miglior.oggetto.fclust.SILF(df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering_SILF <- miglior.oggetto.fclust.SILF(df,res.fkm)
rm(b)
dati_csv <- read.csv("pokemon.csv")
library(fclust)
library(mlbench)
library(ggplot2)
library(lattice)
library(caret)
library(factoextra)
library(cluster)
dati_csv <- read.csv("pokemon.csv")
#dati_csv <- read.csv("wine.csv")
df <- data.frame(dati_csv)
rm(dati_csv)
print(df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
cat("Ho rimosso le colonne NON numeric, rimangono le seguenti colonne")
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
library(fclust)
library(mlbench)
library(ggplot2)
library(lattice)
library(caret)
library(factoextra)
library(cluster)
dati_csv <- read.csv("pokemon.csv")
#dati_csv <- read.csv("wine.csv")
df <- data.frame(dati_csv)
rm(dati_csv)
print(df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
cat("Ho rimosso le colonne NON numeric, rimangono le seguenti colonne\n")
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
rm(rimuovi_colonne)
View(df)
plot(miglior_clustering_SILF,pca=TRUE)
#il dataset potrebbe avere valori mancanti
#rappresentati con NA, scartiamo per semplicità le righe
#contenenti valori NA
df <- na.omit(df)
#usiamo un numero inferiore di tuple per semplicità se il dataset è grande
riduzione_df <- function(df)
{
perc <- readline(prompt="Inserisci un numero da 0 a 1: ")
perc <- as.double(perc)
if(perc < 0.0 | perc > 1.0)
{
print("Numero non compreso tra 0 e 1, la percentuale è stata impostata a 1")
return(df)
}
#decidiamo la percentuale di righe che vogliamo usare
num_tuple <- round(perc*nrow(df))
set.seed(111222333)
pos_rand <- sample(1:nrow(df),num_tuple)
return(df[pos_rand,])
}
df <- riduzione_df(df)
rm(riduzione_df)
#Quello che possiamo fare è scartare features ridondanti
#Sfrutteremo il metodo findCorrelation per trovare le variabili
#con forti gradi di correlazione(in genere con forti si intende con
#grado maggiore o uguale 0.75)
corr <- cor(df[,1:ncol(df)])
print(corr)
variabili.molto.correlate <- findCorrelation(corr,cutoff = 0.75)
str <- paste("Le seguenti variabili sono molto correlate alle altre, dunque le scartiamo \n",toString(variabili.molto.correlate))
cat(str)
#con questo semplice for troviamo i nomi delle colonne da scartare
var <- c()
for(i in 1:length(variabili.molto.correlate)) {
var <- c(var,colnames(df)[variabili.molto.correlate[i]])
}
#questa operazione permette di rimuovere da df le colonne
#con i nomi trovati nel for
df <- df[, !(names(df) %in% var)]
rm(str)
rm(i)
rm(var)
rm(variabili.molto.correlate)
rm(corr)
gc()
res.fkm <- FKM(df,k=3,index="SIL.F",alpha=1)
#stampiamo il coeff di fuzzy Silhouette
Fclust.index(res.fkm,index="SIL.F",alpha = 1)
#Grazie alla funzione summary visualizziamo tutte le informazioni dell'oggetto
#tornato in output dalla funzione FKM
sum.res.fkm <- summary(res.fkm)
#una funzione abbastanza simile è la print eseguita su un oggetto fclust
#darà diverse diverse informazioni riguardo l'output come la summary
#però ne darà di meno e in maniera più compatta
print(res.fkm)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(res.fkm)
plot(res.fkm,pca=TRUE)
#Tramite la funzione Fclust.index con i seguenti parametri otteniamo
# il valore di Silhouette fuzzy, un parametro che ci indica la qualità
#dei nostri risultati
res.SilF.FKM <- Fclust.index(res.fkm,index="SIL.F",alpha = 1)
str <- paste("Il coefficiente di fuzzy Silhouette è ", toString(res.SilF.FKM))
cat(str)
rm(str)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering_SILF <- miglior.oggetto.fclust.SILF(df,res.fkm)
info.principali.fclust(miglior_clustering_SILF)
plot(miglior_clustering_SILF,pca=TRUE)
grep("noise","FKM.noise",fixed = TRUE)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(miglior_clustering_SILF)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(miglior_clustering_SILF)
source("validazione_fclust.R")
validazione(1)
View(res.fkm)
res.fkm[["H"]]
cat(res.fkm[["H"]])
print(res.fkm[["H"]])
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(miglior_clustering_SILF)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(miglior_clustering_SILF)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(miglior_clustering_SILF)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(miglior_clustering_SILF)
View(miglior_clustering_SILF)
source("validazione_fclust_SILF.R")
cat(res.SilF.FKM)
source("validazione_fclust_SILF.R")
validazione.fclust.SILF(1)
validazione.fclust.SILF(miglior_clustering_SILF)
source("validazione_fclust_SILF.R")
validazione.fclust.SILF(miglior_clustering_SILF)
source("validazione_fclust_SILF.R")
source("validazione_fclust_SILF.R")
validazione.fclust.SILF(miglior_clustering_SILF)
source("validazione_fclust_SILF.R")
validazione.fclust.SILF(miglior_clustering_SILF)
source("validazione_fclust_SILF.R")
validazione.fclust.SILF(miglior_clustering_SILF)
source("validazione_fclust_SILF.R")
#passando print = FALSE si disattivano le stampe
validazione.fclust.SILF(miglior_clustering_SILF)
#passando print = FALSE si disattivano le stampe
validazione.fclust.SILF(miglior_clustering_SILF,print = FALSE)
rm(validazione)
source("validazione_fclust_SILF.R")
#passando print = FALSE si disattivano le stampe(tranne il coeff. di fuzzy sil.)
validazione.fclust.SILF(miglior_clustering_SILF,print = FALSE)
clustvarsel()
install.packages("clustvarsel")
library(clustvarsel)
dati_csv <- read.csv("pokemon.csv")
#dati_csv <- read.csv("wine.csv")
df <- data.frame(dati_csv)
rm(dati_csv)
print(df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
cat("Ho rimosso le colonne NON numeric, rimangono le seguenti colonne\n")
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
a <- clustvarsel(df)
View(a)
a[["variables"]]
install.packages("Boruta")
dati_csv <- read.csv("pokemon.csv")
#dati_csv <- read.csv("wine.csv")
df <- data.frame(dati_csv)
rm(dati_csv)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
cat("Ho rimosso le colonne NON numeric, rimangono le seguenti colonne\n")
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
bortrain <- Boruta(df)
library(Boruta)
bortrain <- Boruta(df)
dati_csv <- read.csv("wine.csv")
#dati_csv <- read.csv("wine.csv")
df <- data.frame(dati_csv)
rm(dati_csv)
print(df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
cat("Ho rimosso le colonne NON numeric, rimangono le seguenti colonne\n")
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
rm(rimuovi_colonne)
#il dataset potrebbe avere valori mancanti
#rappresentati con NA, scartiamo per semplicità le righe
#contenenti valori NA
df <- na.omit(df)
#usiamo un numero inferiore di tuple per semplicità se il dataset è grande
riduzione_df <- function(df)
{
perc <- readline(prompt="Inserisci un numero da 0 a 1: ")
perc <- as.double(perc)
if(perc < 0.0 | perc > 1.0)
{
print("Numero non compreso tra 0 e 1, la percentuale è stata impostata a 1")
return(df)
}
#decidiamo la percentuale di righe che vogliamo usare
num_tuple <- round(perc*nrow(df))
set.seed(111222333)
pos_rand <- sample(1:nrow(df),num_tuple)
return(df[pos_rand,])
}
df <- riduzione_df(df)
rm(riduzione_df)
#Quello che possiamo fare è scartare features ridondanti
#Sfrutteremo il metodo findCorrelation per trovare le variabili
#con forti gradi di correlazione(in genere con forti si intende con
#grado maggiore o uguale 0.75)
corr <- cor(df[,1:ncol(df)])
print(corr)
variabili.molto.correlate <- findCorrelation(corr,cutoff = 0.75)
library(caret)
variabili.molto.correlate <- findCorrelation(corr,cutoff = 0.75)
if(length(variabili.molto.correlate) > 0 )
{
str <- paste("Le seguenti variabili sono molto correlate alle altre, dunque le scartiamo \n",toString(variabili.molto.correlate))
cat(str)
#con questo semplice for troviamo i nomi delle colonne da scartare
var <- c()
for(i in 1:length(variabili.molto.correlate)) {
var <- c(var,colnames(df)[variabili.molto.correlate[i]])
}
#questa operazione permette di rimuovere da df le colonne
#con i nomi trovati nel for
df <- df[, !(names(df) %in% var)]
} else{
cat("Nessuna variabile scartata")
}
rm(i)
rm(variabili.molto.correlate)
rm(corr)
dati_csv <- read.csv("wine.csv")
dati_csv <- read.csv("wine.csv")
#dati_csv <- read.csv("wine.csv")
df <- data.frame(dati_csv)
rm(dati_csv)
print(df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
cat("Ho rimosso le colonne NON numeric, rimangono le seguenti colonne\n")
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
rm(rimuovi_colonne)
#il dataset potrebbe avere valori mancanti
#rappresentati con NA, scartiamo per semplicità le righe
#contenenti valori NA
df <- na.omit(df)
#usiamo un numero inferiore di tuple per semplicità se il dataset è grande
riduzione_df <- function(df)
{
perc <- readline(prompt="Inserisci un numero da 0 a 1: ")
perc <- as.double(perc)
if(perc < 0.0 | perc > 1.0)
{
print("Numero non compreso tra 0 e 1, la percentuale è stata impostata a 1")
return(df)
}
#decidiamo la percentuale di righe che vogliamo usare
num_tuple <- round(perc*nrow(df))
set.seed(111222333)
pos_rand <- sample(1:nrow(df),num_tuple)
return(df[pos_rand,])
}
df <- riduzione_df(df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
cat("Ho rimosso le colonne NON numeric, rimangono le seguenti colonne\n")
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
dati_csv <- read.csv("wine.csv")
#dati_csv <- read.csv("wine.csv")
df <- data.frame(dati_csv)
rm(dati_csv)
print(df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(df, is.numeric))
df <- df[ , nums]
cat("Ho rimosso le colonne NON numeric\n")
if(ncol(df) < 20) #ovviamente se le colonne sono troppe non ha senso eseguire questo if
{
cat("Rimangono le seguenti colonne:\n")
print(colnames(df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
df <- df[, !(names(df) %in% col)]
}
}
return(df)
}
df <- rimuovi_colonne(df)
rm(rimuovi_colonne)
#il dataset potrebbe avere valori mancanti
#rappresentati con NA, scartiamo per semplicità le righe
#contenenti valori NA
df <- na.omit(df)
#usiamo un numero inferiore di tuple per semplicità se il dataset è grande
riduzione_df <- function(df)
{
perc <- readline(prompt="Inserisci un numero da 0 a 1: ")
perc <- as.double(perc)
if(perc < 0.0 | perc > 1.0)
{
print("Numero non compreso tra 0 e 1, la percentuale è stata impostata a 1")
return(df)
}
#decidiamo la percentuale di righe che vogliamo usare
num_tuple <- round(perc*nrow(df))
set.seed(111222333)
pos_rand <- sample(1:nrow(df),num_tuple)
return(df[pos_rand,])
}
df <- riduzione_df(df)
rm(riduzione_df)
#Quello che possiamo fare è scartare features ridondanti
#Sfrutteremo il metodo findCorrelation per trovare le variabili
#con forti gradi di correlazione(in genere con forti si intende con
#grado maggiore o uguale 0.75)
corr <- cor(df[,1:ncol(df)])
print(corr)
variabili.molto.correlate <- findCorrelation(corr,cutoff = 0.75)
if(length(variabili.molto.correlate) > 0 )
{
str <- paste("Le seguenti variabili sono molto correlate alle altre, dunque le scartiamo \n",toString(variabili.molto.correlate))
cat(str)
#con questo semplice for troviamo i nomi delle colonne da scartare
var <- c()
for(i in 1:length(variabili.molto.correlate)) {
var <- c(var,colnames(df)[variabili.molto.correlate[i]])
}
#questa operazione permette di rimuovere da df le colonne
#con i nomi trovati nel for
df <- df[, !(names(df) %in% var)]
} else{
cat("Nessuna variabile scartata")
}
rm(i)
rm(variabili.molto.correlate)
rm(corr)
rm(str)
rm(var)
View(df)
