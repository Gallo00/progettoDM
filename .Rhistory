#rimuovere tutte le colonne non numeric
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
return(CC_df)
}
CC_df <- rimuovi_colonne(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
print(colnames(CC_df))
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
return(CC_df)
}
View(CC_df)
CC_df <- rimuovi_colonne(CC_df)
View(CC_df)
View(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
print(colnames(CC_df))
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare: "))!="stop")
{
CC_df <- CC_df[, !(names(CC_df) %in% col)]
}
return(CC_df)
}
dati_csv <- read.csv("pokemon.csv")
CC_df <- data.frame(dati_csv)
rm(dati_csv)
print(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
print(colnames(CC_df))
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare: "))!="stop")
{
CC_df <- CC_df[, !(names(CC_df) %in% col)]
}
return(CC_df)
}
CC_df <- rimuovi_colonne(CC_df)
dati_csv <- read.csv("pokemon.csv")
CC_df <- data.frame(dati_csv)
rm(dati_csv)
print(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
print(colnames(CC_df))
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare: "))!="stop")
{
CC_df <- CC_df[, !(names(CC_df) %in% col)]
}
return(CC_df)
}
CC_df <- rimuovi_colonne(CC_df)
dati_csv <- read.csv("pokemon.csv")
CC_df <- data.frame(dati_csv)
rm(dati_csv)
print(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
print(colnames(CC_df))
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
CC_df <- CC_df[, !(names(CC_df) %in% col)]
}
return(CC_df)
}
CC_df <- rimuovi_colonne(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
print(colnames(CC_df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
CC_df <- CC_df[, !(names(CC_df) %in% col)]
}
return(CC_df)
}
CC_df <- rimuovi_colonne(CC_df)
#il dataset potrebbe avere valori mancanti
#rappresentati con NA, scartiamo per semplicità le righe
#contenenti valori NA
CC_df <- na.omit(CC_df)
#usiamo un numero inferiore di tuple per semplicità se il dataset è grande
riduzione_df <- function(CC_df)
{
perc <- readline(prompt="Inserisci un numero da 0 a 1: ")
perc <- as.double(perc)
if(perc < 0.0 | perc > 1.0)
{
print("Numero non compreso tra 0 e 1, la percentuale è stata impostata a 1")
return(CC_df)
}
#decidiamo la percentuale di righe che vogliamo usare
num_tuple <- round(perc*nrow(CC_df))
set.seed(111222333)
pos_rand <- sample(1:nrow(CC_df),num_tuple)
return(CC_df[pos_rand,])
}
CC_df <- riduzione_df(CC_df)
#Quello che possiamo fare è scartare features ridondanti
#Sfrutteremo il metodo findCorrelation per trovare le variabili
#con forti gradi di correlazione(in genere con forti si intende con
#grado maggiore o uguale 0.75)
corr <- cor(CC_df[,1:ncol(CC_df)])
print(corr)
variabili.molto.correlate <- findCorrelation(corr,cutoff = 0.75)
str <- paste("Le seguenti variabili sono molto correlate alle altre, dunque le scartiamo \n",toString(variabili.molto.correlate))
cat(str)
#con questo semplice for troviamo i nomi delle colonne da scartare
var <- c()
for(i in 1:length(variabili.molto.correlate)) {
var <- c(var,colnames(CC_df)[variabili.molto.correlate[i]])
}
#questa operazione permette di rimuovere da CC_df le colonne
#con i nomi trovati nel for
CC_df <- CC_df[, !(names(CC_df) %in% var)]
rm(str)
rm(i)
rm(var)
rm(variabili.molto.correlate)
rm(corr)
gc()
res.fkm <- FKM(CC_df,k=3,index="SIL.F",alpha=1)
#stampiamo il coeff di fuzzy Silhouette
Fclust.index(res.fkm,index="SIL.F",alpha = 1)
#Grazie alla funzione summary visualizziamo tutte le informazioni dell'oggetto
#tornato in output dalla funzione FKM
sum.res.fkm <- summary(res.fkm)
#una funzione abbastanza simile è la print eseguita su un oggetto fclust
#darà diverse diverse informazioni riguardo l'output come la summary
#però ne darà di meno e in maniera più compatta
print(res.fkm)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(res.fkm)
plot(res.fkm,pca=TRUE)
#Tramite la funzione Fclust.index con i seguenti parametri otteniamo
# il valore di Silhouette fuzzy, un parametro che ci indica la qualità
#dei nostri risultati
res.SilF.FKM <- Fclust.index(res.fkm,index="SIL.F",alpha = 1)
str <- paste("Il coefficiente di fuzzy Silhouette è ", toString(res.SilF.FKM))
cat(str)
rm(str)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm,k=3)
res.fkm <- FKM(CC_df,k=3,stand=1,index="SIL.F",alpha=1)
#stampiamo il coeff di fuzzy Silhouette
Fclust.index(res.fkm,index="SIL.F",alpha = 1)
#Grazie alla funzione summary visualizziamo tutte le informazioni dell'oggetto
#tornato in output dalla funzione FKM
sum.res.fkm <- summary(res.fkm)
#una funzione abbastanza simile è la print eseguita su un oggetto fclust
#darà diverse diverse informazioni riguardo l'output come la summary
#però ne darà di meno e in maniera più compatta
print(res.fkm)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(res.fkm)
plot(res.fkm,pca=TRUE)
#Tramite la funzione Fclust.index con i seguenti parametri otteniamo
# il valore di Silhouette fuzzy, un parametro che ci indica la qualità
#dei nostri risultati
res.SilF.FKM <- Fclust.index(res.fkm,index="SIL.F",alpha = 1)
str <- paste("Il coefficiente di fuzzy Silhouette è ", toString(res.SilF.FKM))
cat(str)
rm(str)
#usiamo un numero inferiore di tuple per semplicità se il dataset è grande
riduzione_df <- function(CC_df)
{
perc <- readline(prompt="Inserisci un numero da 0 a 1: ")
perc <- as.double(perc)
if(perc < 0.0 | perc > 1.0)
{
print("Numero non compreso tra 0 e 1, la percentuale è stata impostata a 1")
return(CC_df)
}
#decidiamo la percentuale di righe che vogliamo usare
num_tuple <- round(perc*nrow(CC_df))
set.seed(111222333)
pos_rand <- sample(1:nrow(CC_df),num_tuple)
return(CC_df[pos_rand,])
}
CC_df <- riduzione_df(CC_df)
library(fclust)
library(mlbench)
library(ggplot2)
library(lattice)
library(caret)
library(factoextra)
library(cluster)
dati_csv <- read.csv("pokemon.csv")
CC_df <- data.frame(dati_csv)
rm(dati_csv)
print(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
print(colnames(CC_df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
CC_df <- CC_df[, !(names(CC_df) %in% col)]
}
return(CC_df)
}
CC_df <- rimuovi_colonne(CC_df)
library(fclust)
library(mlbench)
library(ggplot2)
library(lattice)
library(caret)
library(factoextra)
library(cluster)
dati_csv <- read.csv("pokemon.csv")
CC_df <- data.frame(dati_csv)
rm(dati_csv)
print(CC_df)
#Se nel dataframe è presente una colonna(o più) che contiene degli id, ovviamente
# la scartiamo
rimuovi_colonne <- function(CC_df)
{
#rimuovere tutte le colonne non numeric
nums <- unlist(lapply(CC_df, is.numeric))
CC_df <- CC_df[ , nums]
print(colnames(CC_df))
#tramite input da tastiera chiedere all'utente quali altre colonne vuole rimuovere
while((col <- readline(prompt="Inserisci nome colonna da eliminare(stop_remove per fermarsi): "))!="stop_remove")
{
CC_df <- CC_df[, !(names(CC_df) %in% col)]
}
return(CC_df)
}
CC_df <- rimuovi_colonne(CC_df)
#il dataset potrebbe avere valori mancanti
#rappresentati con NA, scartiamo per semplicità le righe
#contenenti valori NA
CC_df <- na.omit(CC_df)
#usiamo un numero inferiore di tuple per semplicità se il dataset è grande
riduzione_df <- function(CC_df)
{
perc <- readline(prompt="Inserisci un numero da 0 a 1: ")
perc <- as.double(perc)
if(perc < 0.0 | perc > 1.0)
{
print("Numero non compreso tra 0 e 1, la percentuale è stata impostata a 1")
return(CC_df)
}
#decidiamo la percentuale di righe che vogliamo usare
num_tuple <- round(perc*nrow(CC_df))
set.seed(111222333)
pos_rand <- sample(1:nrow(CC_df),num_tuple)
return(CC_df[pos_rand,])
}
CC_df <- riduzione_df(CC_df)
#Quello che possiamo fare è scartare features ridondanti
#Sfrutteremo il metodo findCorrelation per trovare le variabili
#con forti gradi di correlazione(in genere con forti si intende con
#grado maggiore o uguale 0.75)
corr <- cor(CC_df[,1:ncol(CC_df)])
print(corr)
variabili.molto.correlate <- findCorrelation(corr,cutoff = 0.75)
str <- paste("Le seguenti variabili sono molto correlate alle altre, dunque le scartiamo \n",toString(variabili.molto.correlate))
cat(str)
#con questo semplice for troviamo i nomi delle colonne da scartare
var <- c()
for(i in 1:length(variabili.molto.correlate)) {
var <- c(var,colnames(CC_df)[variabili.molto.correlate[i]])
}
#questa operazione permette di rimuovere da CC_df le colonne
#con i nomi trovati nel for
CC_df <- CC_df[, !(names(CC_df) %in% var)]
rm(str)
rm(i)
rm(var)
rm(variabili.molto.correlate)
rm(corr)
gc()
res.fkm <- FKM(CC_df,k=3,index="SIL.F",alpha=1)
#stampiamo il coeff di fuzzy Silhouette
Fclust.index(res.fkm,index="SIL.F",alpha = 1)
#Grazie alla funzione summary visualizziamo tutte le informazioni dell'oggetto
#tornato in output dalla funzione FKM
sum.res.fkm <- summary(res.fkm)
#una funzione abbastanza simile è la print eseguita su un oggetto fclust
#darà diverse diverse informazioni riguardo l'output come la summary
#però ne darà di meno e in maniera più compatta
print(res.fkm)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(res.fkm)
plot(res.fkm,pca=TRUE)
#Tramite la funzione Fclust.index con i seguenti parametri otteniamo
# il valore di Silhouette fuzzy, un parametro che ci indica la qualità
#dei nostri risultati
res.SilF.FKM <- Fclust.index(res.fkm,index="SIL.F",alpha = 1)
str <- paste("Il coefficiente di fuzzy Silhouette è ", toString(res.SilF.FKM))
cat(str)
rm(str)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm,k=3)
a <- FKM.ent(df_norm,k=k,stand=0,index="SIL.F",alpha=1)
a <- FKM.ent(CC_df,k=k,stand=0,index="SIL.F",alpha=1)
a <- FKM.ent(CC_df,k=2:6,stand=0,index="SIL.F",alpha=1)
a <- FKM.ent(CC_df,k=2:6,stand=1,index="SIL.F",alpha=1)
View(a)
info.principali.fclust(a)
res.fkm <- FKM(CC_df,k=3,stand=1,index="SIL.F",alpha=1)
#stampiamo il coeff di fuzzy Silhouette
Fclust.index(res.fkm,index="SIL.F",alpha = 1)
#Grazie alla funzione summary visualizziamo tutte le informazioni dell'oggetto
#tornato in output dalla funzione FKM
sum.res.fkm <- summary(res.fkm)
#una funzione abbastanza simile è la print eseguita su un oggetto fclust
#darà diverse diverse informazioni riguardo l'output come la summary
#però ne darà di meno e in maniera più compatta
print(res.fkm)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(res.fkm)
plot(res.fkm,pca=TRUE)
res.fkm <- FKM(CC_df,k=3,index="SIL.F",alpha=1)
#stampiamo il coeff di fuzzy Silhouette
Fclust.index(res.fkm,index="SIL.F",alpha = 1)
#Grazie alla funzione summary visualizziamo tutte le informazioni dell'oggetto
#tornato in output dalla funzione FKM
sum.res.fkm <- summary(res.fkm)
#una funzione abbastanza simile è la print eseguita su un oggetto fclust
#darà diverse diverse informazioni riguardo l'output come la summary
#però ne darà di meno e in maniera più compatta
print(res.fkm)
#per permetterci di vedere un "riassunto" dei risultati creiamo
#la funzione info.principali.fclust che conserviamo in un altro file R
source("info_principali_fclust.R")
info.principali.fclust(res.fkm)
plot(res.fkm,pca=TRUE)
#Tramite la funzione Fclust.index con i seguenti parametri otteniamo
# il valore di Silhouette fuzzy, un parametro che ci indica la qualità
#dei nostri risultati
res.SilF.FKM <- Fclust.index(res.fkm,index="SIL.F",alpha = 1)
str <- paste("Il coefficiente di fuzzy Silhouette è ", toString(res.SilF.FKM))
cat(str)
rm(str)
source("miglior_oggetto_fclust_SILF.R")
gc()
source("miglior_oggetto_fclust_SILF.R")
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm,k=3)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
info.principali.fclust(miglior_clustering)
plot(miglior_clustering,pca=TRUE)
log(0)
log("ciao")
try(log("ciao"))
try(log("not a number"), silent = TRUE)
tryCatch( { result <- log(-1); print(result) }
, warning = function(w) { print("Hey, a warning") })
tryCatch( { a <- FKM.ent(df_norm,k=k,stand=0,index="SIL.F",alpha=1)}
, warning = function(w) { print("Hey, a warning") })
tryCatch( { a <- FKM.ent(CC_df,k=2:6,stand=0,index="SIL.F",alpha=1)}
, warning = function(w) { print("Hey, a warning") })
tryCatch( {a <- <- FKM.ent(CC_df,k=2:6,stand=0,index="SIL.F",alpha=1) }
, error = function(e) {print("ciao")})
tryCatch( {a <-FKM.ent(CC_df,k=2:6,stand=0,index="SIL.F",alpha=1) }
, error = function(e) {print("ciao")})
tryCatch( {a <-FKM.ent(CC_df,k=2:6,stand=0,index="SIL.F",alpha=1) }
, error = function(e) {a <-FKM.ent(CC_df,k=2:6,stand=1,index="SIL.F",alpha=1)})
a
View(a)
source("miglior_oggetto_fclust_SILF.R")
, error = function(e) {a <-FKM.ent(CC_df,k=2:6,stand=1,index="SIL.F",alpha=1)})
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
a <- NULL
a <- FKM(CC_df,k=3,index="SIL.F",alpha=1)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
a <- fclust()
a <- fclust(0)
a <- NULL
class(a)
as(a,"fclust")
as(a,fclust)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
d <- 3
tryCatch( { d <- log(44) }
, error = function(e)
{print("log non possibile")})
d <- 3
try(d <- log(-1))
d <- 3
try(d <- log(-1), silent=TRUE)
tryCatch( { d <- log(44) }
, error = function(e)
{})
tryCatch( { d <- log(-1) }
, error = function(e)
{})
tryCatch( { d <- log(-1) }
, error = function(e)
{ d <- 1})
tryCatch( { d <- log(-1) }
, warning = function(e)
{ d <- 1})
tryCatch( { d <- log(-1) }
, warning = function(e)
{ d <- 1})
tryCatch( { d <- log(-1) }
, warning = function(w)
{ d <- 1})
tryCatch( { d <- log(-1) }
, warning = function(w)
{ d <- 1})
a <- FKM.ent(CC_df,k=k,stand=1,index="SIL.F",alpha=1)
a <- FKM.ent(CC_df,k=2:6,stand=1,index="SIL.F",alpha=1)
tryCatch( {a <- FKM.ent(df,k=1,index="SIL.F",alpha=1) }
, error = function(e)
{print("Metodi ent eseguiti con stand=1")})
tryCatch( {a <- FKM.ent(df,k=1,index="SIL.F",alpha=1) }
, error = function(e)
{})
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
info.principali.fclust(miglior_clustering)
plot(miglior_clustering,pca=TRUE)
plot(miglior_clustering,pca=TRUE)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
rm(d)
source("miglior_oggetto_fclust_SILF.R")
gc()
miglior_clustering <- miglior.oggetto.fclust.SILF(CC_df,res.fkm)
info.principali.fclust(miglior_clustering)
View(miglior_clustering)
miglior_clustering[["clus"]]
plot(miglior_clustering,pca=TRUE)
miglior_clustering_SILF <- miglior_clustering
rm(miglior_clustering)
rm(a)
